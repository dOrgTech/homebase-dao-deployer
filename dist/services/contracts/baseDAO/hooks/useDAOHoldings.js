'use strict';var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator['throw'](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __rest=this&&this.__rest||function(s,e){var t={};for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];if(s!=null&&typeof Object.getOwnPropertySymbols==='function')for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i]))t[p[i]]=s[p[i]];}return t;};Object.defineProperty(exports,'__esModule',{value:true});exports.useDAONFTHoldings=exports.useDAOHoldings=void 0;const react_query_1=require('react-query');const tokenBalances_1=require('../../../bakingBad/tokenBalances');const useDAO_1=require('../../../services/dao/hooks/useDAO');const useTezos_1=require('../../../beacon/hooks/useTezos');const react_1=require('react');const Token_1=require('../../../../models/Token');const useDAOHoldings=contractAddress=>{const {data:dao}=(0,useDAO_1.useDAO)(contractAddress);const {network}=(0,useTezos_1.useTezos)();const _a=(0,react_query_1.useQuery)(['balances',contractAddress],()=>__awaiter(void 0,void 0,void 0,function*(){return yield(0,tokenBalances_1.getDAOBalances)(dao.data.address,network);}),{enabled:!!dao}),{data}=_a,rest=__rest(_a,['data']);const tokens=(0,react_1.useMemo)(()=>{if(!data){return[];}return data.filter(holding=>!(holding.token instanceof Token_1.NFT));},[data]);return Object.assign({tokenHoldings:tokens,data},rest);};exports.useDAOHoldings=useDAOHoldings;const useDAONFTHoldings=contractAddress=>{const {data:dao}=(0,useDAO_1.useDAO)(contractAddress);const {network}=(0,useTezos_1.useTezos)();const _a=(0,react_query_1.useQuery)(['nftbalances',contractAddress],()=>__awaiter(void 0,void 0,void 0,function*(){return yield(0,tokenBalances_1.getDAONFTBalances)(dao.data.address,network);}),{enabled:!!dao}),{data}=_a,rest=__rest(_a,['data']);const nfts=(0,react_1.useMemo)(()=>{if(!data){return null;}return data.filter(holding=>holding.token instanceof Token_1.NFT&&holding.balance.isGreaterThan(0));},[data]);return Object.assign({nftHoldings:nfts,data},rest);};exports.useDAONFTHoldings=useDAONFTHoldings;